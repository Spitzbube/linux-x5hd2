#include "higmac.h"

#ifndef CONFIG_S40_FPGA
#include "fephy_fix.h"
u32 phy_fix_param[] = {
	0x33f9,0xbd,
	0x33fa,0x34,
	0x33fb,0x00,
	0x33fc,0x39,
	0x3400,0x39,
	0x3401,0xCC,
	0x3402,0x00,
	0x3403,0x02,
	0x3404,0xFD,
	0x3405,0xFF,
	0x3406,0xF0,
	0x3407,0xF6,
	0x3408,0x34,
	0x3409,0x9B,
	0x340A,0x26,
	0x340B,0x0E,
	0x340C,0xC6,
	0x340D,0x01,
	0x340E,0xF7,
	0x340F,0x34,
	0x3410,0x9B,
	0x3411,0xCC,
	0x3412,0x34,
	0x3413,0x1B,
	0x3414,0xFD,
	0x3415,0x00,
	0x3416,0xCB,
	0x3417,0x7F,
	0x3418,0x01,
	0x3419,0xB9,
	0x341A,0x39,
	0x341B,0xF6,
	0x341C,0x01,
	0x341D,0xB9,
	0x341E,0xC1,
	0x341F,0x13,
	0x3420,0x24,
	0x3421,0x78,
	0x3422,0xBD,
	0x3423,0xE4,
	0x3424,0x0A,
	0x3425,0x34,
	0x3426,0x4C,
	0x3427,0x34,
	0x3428,0x4F,
	0x3429,0x34,
	0x342A,0x5B,
	0x342B,0x34,
	0x342C,0x5F,
	0x342D,0x34,
	0x342E,0x63,
	0x342F,0x34,
	0x3430,0x66,
	0x3431,0x34,
	0x3432,0x6A,
	0x3433,0x34,
	0x3434,0x6E,
	0x3435,0x34,
	0x3436,0x72,
	0x3437,0x34,
	0x3438,0x76,
	0x3439,0x34,
	0x343A,0x7A,
	0x343B,0x34,
	0x343C,0x7D,
	0x343D,0x34,
	0x343E,0x81,
	0x343F,0x34,
	0x3440,0x85,
	0x3441,0x34,
	0x3442,0x88,
	0x3443,0x34,
	0x3444,0x8C,
	0x3445,0x34,
	0x3446,0x90,
	0x3447,0x34,
	0x3448,0x94,
	0x3449,0x34,
	0x344A,0x97,
	0x344B,0x39,
	0x344C,0xBD,
	0x344D,0xB5,
	0x344E,0x6D,
	0x344F,0xBD,
	0x3450,0xB5,
	0x3451,0x7B,
	0x3452,0xF6,
	0x3453,0x20,
	0x3454,0x10,
	0x3455,0xC4,
	0x3456,0xE7,
	0x3457,0xF7,
	0x3458,0x20,
	0x3459,0x10,
	0x345A,0x39,
	0x345B,0xBD,
	0x345C,0xB5,
	0x345D,0xB9,
	0x345E,0x39,
	0x345F,0xBD,
	0x3460,0xB5,
	0x3461,0xDC,
	0x3462,0x39,
	0x3463,0xBD,
	0x3464,0xB6,
	0x3465,0x47,
	0x3466,0xBD,
	0x3467,0xB6,
	0x3468,0x6A,
	0x3469,0x39,
	0x346A,0xBD,
	0x346B,0xB6,
	0x346C,0xB7,
	0x346D,0x39,
	0x346E,0xBD,
	0x346F,0xB6,
	0x3470,0xE7,
	0x3471,0x39,
	0x3472,0xBD,
	0x3473,0xB7,
	0x3474,0x20,
	0x3475,0x39,
	0x3476,0xBD,
	0x3477,0xB7,
	0x3478,0x56,
	0x3479,0x39,
	0x347A,0xBD,
	0x347B,0xB7,
	0x347C,0x9C,
	0x347D,0xBD,
	0x347E,0xB7,
	0x347F,0xF1,
	0x3480,0x39,
	0x3481,0xBD,
	0x3482,0xB9,
	0x3483,0x36,
	0x3484,0x39,
	0x3485,0xBD,
	0x3486,0xB9,
	0x3487,0x54,
	0x3488,0xBD,
	0x3489,0xB9,
	0x348A,0x8B,
	0x348B,0x39,
	0x348C,0xBD,
	0x348D,0xB9,
	0x348E,0xA8,
	0x348F,0x39,
	0x3490,0xBD,
	0x3491,0xBA,
	0x3492,0x01,
	0x3493,0x39,
	0x3494,0xBD,
	0x3495,0xBA,
	0x3496,0x22,
	0x3497,0xBD,
	0x3498,0xBA,
	0x3499,0x42,
	0x349A,0x39,
	0x349B,0x00,
	0x3400,0x01,
	0x33f8,0x01
};

/* fix FEPHY for better eye diagram */
void higmac_internal_fephy_performance_fix(struct higmac_netdev_local *ld)
{
	int phy_addr = ld->phy->addr;
	int phy_id = 0, v;

	v = get_phy_id(ld->mii_bus_using, phy_addr, &phy_id);
	if (v) {
		pr_err("mii_bus:%s get phy(addr=%d) failed!\n",
				ld->mii_bus_using->name, phy_addr);
		return;
	}

	if (phy_id == HIGMAC_INTERNAL_FEPHY_ID) {
		int count;
		pr_info("Internal FEPHY(phy id:0x%x) fix.\n", phy_id);
		count = sizeof(phy_fix_param)/sizeof(phy_fix_param[0]);
		if (count % 2)
			pr_warning("internal FEPHY fix register count is not right.\n");
		count /= 2;
		phy_expanded_write_bulk(ld->phy, phy_fix_param, count);
	}
}

int set_phy_expanded_access_mode(struct phy_device *phy_dev, int access_mode)
{
	int v, ret;

	v = phy_read(phy_dev, MII_MISC_CTL);
	v &= (~0x3);
	v |= (access_mode & 0x3);
	ret = phy_write(phy_dev, MII_MISC_CTL, v);

	return ret;
}

int phy_expanded_read(struct phy_device *phy_dev, u32 reg_addr)
{
	int v, ret;

	v = phy_read(phy_dev, MII_BMCR);
	v |= BMCR_PDOWN;
	phy_write(phy_dev, MII_BMCR, v);

	phy_write(phy_dev, MII_EXPMA, reg_addr);
	ret = phy_read(phy_dev, MII_EXPMD);

	v = phy_read(phy_dev, MII_BMCR);
	v &= (~BMCR_PDOWN);
	phy_write(phy_dev, MII_BMCR, v);

	return ret;
}

int phy_expanded_write(struct phy_device *phy_dev, u32 reg_addr, u16 val)
{
	int v, ret;

	v = phy_read(phy_dev, MII_BMCR);
	v |= BMCR_PDOWN;
	phy_write(phy_dev, MII_BMCR, v);

	phy_write(phy_dev, MII_EXPMA, reg_addr);
	ret = phy_write(phy_dev, MII_EXPMD, val);

	v = phy_read(phy_dev, MII_BMCR);
	v &= (~BMCR_PDOWN);
	phy_write(phy_dev, MII_BMCR, v);

	return ret;
}

int phy_expanded_write_bulk(struct phy_device *phy_dev, u32 reg_and_val[], int count)
{
	int i, v, ret=0;
	u32 reg_addr;
	u16 val;

	v = phy_read(phy_dev, MII_BMCR);
	v |= BMCR_PDOWN;
	phy_write(phy_dev, MII_BMCR, v);

	for (i=0; i< (2*count); i += 2) {
		reg_addr = reg_and_val[i];
		val = (u16)reg_and_val[i+1];
		phy_write(phy_dev, MII_EXPMA, reg_addr);
		ret = phy_write(phy_dev, MII_EXPMD, val);
	}

	pr_info("internal FEPHY fix total %d registers.\n", count);

	v = phy_read(phy_dev, MII_BMCR);
	v &= (~BMCR_PDOWN);
	phy_write(phy_dev, MII_BMCR, v);

	return ret;
}
#endif
